// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MalwareDetection{
    struct Vote{
        address payable a;
        bool favor;
    }
    struct status{
        string link;
        Vote[5] votes;
        uint256 positive;
        uint256 total;
        bool completed;
        uint fees;
        address payable publisher;
        uint256 publishTime;
        bool genuine;
        mapping(address => bool) voted;
    }
    struct returnStatus{
        string link;
        uint256 positive;
        uint256 total;
        bool completed;
        address payable publisher;
        uint256 publishTime;
        bool genuine;
    }
    
    event Completion(string hashValue, bool genuine, uint total, uint positive);
    event CastVote(string hashValue, bool favor, address voter);
    event Published(string hashValue, address publisher, string link, uint time);
    event ErrorMessage(address a, string err, uint256 time);
    mapping(string => status) public m;
    mapping(address => uint) public blockCount;
    uint bal = address(this).balance;
    
    receive () external payable{}
    function publish(string calldata hashValue, string calldata link) public payable returns (string memory){
        if(m[hashValue].fees != 0){
            emit ErrorMessage(msg.sender, "Already published.", block.timestamp);
            address payable p = payable(msg.sender);
            (bool success, ) = p.call{value : msg.value}("");
            require(success, "Payment failed..");
            return "Error";
        }
        if(msg.value != (blockCount[msg.sender] + 1)* 1 ether){
            emit ErrorMessage(msg.sender, "Incorrect amount.", block.timestamp);
            address payable p = payable(msg.sender);
            (bool success, ) = p.call{value : msg.value}("");
            require(success, "Payment failed..");
            return "Error";
        }
        if(bytes(hashValue).length != 4){
            emit ErrorMessage(msg.sender, "Invalid hash value", block.timestamp);
            address payable p = payable(msg.sender);
            (bool success, ) = p.call{value : msg.value}("");
            require(success, "Payment failed..");
            return "Error";
        }
        // require(m[hashValue].total == 0, "Already published.");
        // require(msg.value == (blockCount[msg.sender]+1)*1 ether, "Incorrect amount.");
        // require(bytes(hashValue).length == 4, "Invalid hash value");
        
        m[hashValue].publisher = payable(msg.sender);
        m[hashValue].completed = false;
        m[hashValue].total = 0;
        m[hashValue].positive = 0;
        m[hashValue].fees = msg.value;
        m[hashValue].link = link;
        m[hashValue].publishTime = block.timestamp;
        emit Published(hashValue, msg.sender, link, block.timestamp);
        return "Published.";
    }
    function castVote(string calldata hashValue, bool f) public payable returns (string memory){

        // add checks for publisher and repeat voter
        // require(m[hashValue].publishTime > 0, "Software has not been published here.");
        if(m[hashValue].publishTime == 0){
            emit ErrorMessage(msg.sender, "Software has not been published here", block.timestamp);
            address payable p = payable(msg.sender);
            (bool success, ) = p.call{value : msg.value}("");
            require(success, "Payment failed.");
            return "Error";
        }
        // require(m[hashValue].publisher != payable(msg.sender), "Can't vote on your own product");
        if(m[hashValue].publisher == payable(msg.sender)){
            emit ErrorMessage(msg.sender, "Can't vote on your own product", block.timestamp);
            address payable p = payable(msg.sender);
            (bool success, ) = p.call{value : msg.value}("");
            require(success, "Payment failed.");
            return "Error";
        }
        // require(bytes(hashValue).length == 4, "Invalid hash value.");
        if(bytes(hashValue).length != 4){
            emit ErrorMessage(msg.sender, "Invalid hash value", block.timestamp);
            address payable p = payable(msg.sender);
            (bool success, ) = p.call{value : msg.value}("");
            require(success, "Payment failed.");
            return "Error";
        }
        // require(m[hashValue].voted[msg.sender] == false, "Voted already.");
        if(m[hashValue].voted[msg.sender] == true){
            emit ErrorMessage(msg.sender, "Voted already.", block.timestamp);
            address payable p = payable(msg.sender);
            (bool success, ) = p.call{value : msg.value}("");
            require(success, "Payment failed.");
            return "Error";
        }
        // require(msg.value == 100000 wei, "Incorrect bet amount. 100000 wei is needed");
        if(msg.value != 0.01 ether){
            emit ErrorMessage(msg.sender, "Incorrect bet amount. 0.01 ether is needed", block.timestamp);
            address payable p = payable(msg.sender);
            (bool success, ) = p.call{value : msg.value}("");
            require(success, "Payment failed.");
            return "Error";
        }
        
        if(m[hashValue].completed == false){
            emit CastVote(hashValue, f, msg.sender);
            m[hashValue].voted[msg.sender] = true;
            uint256 current = block.timestamp;
            if(f){
                m[hashValue].positive += 1;
                m[hashValue].votes[m[hashValue].total] = Vote(payable(msg.sender), true);
                m[hashValue].total += 1;
                if(m[hashValue].total == 5 || current - m[hashValue].publishTime > 1 days){
                    m[hashValue].completed = true;
                    if(m[hashValue].positive > m[hashValue].total - m[hashValue].positive){
                        m[hashValue].genuine = true;
                    }
                    else{
                        m[hashValue].genuine = false;
                        blockCount[m[hashValue].publisher]++;
                    }
                    emit Completion(hashValue, m[hashValue].genuine, m[hashValue].total, m[hashValue].positive);
                    // distribute rewards
                    distributeRewards(hashValue);
                }
            }
            else{
                m[hashValue].votes[m[hashValue].total] = Vote(payable(msg.sender), false);
                m[hashValue].total += 1;
                if(m[hashValue].total == 5 || current - m[hashValue].publishTime > 1 days){
                    m[hashValue].completed = true;
                    if(m[hashValue].positive > m[hashValue].total - m[hashValue].positive){
                        m[hashValue].genuine = true;
                    }
                    else{
                        m[hashValue].genuine = false;
                        blockCount[m[hashValue].publisher]++;
                    }
                    emit Completion(hashValue, m[hashValue].genuine, m[hashValue].total, m[hashValue].positive);
                    // distribute rewards
                    distributeRewards(hashValue);
                }
            }
            return "Voted.";    
        }
        else{
            address payable p = payable(msg.sender);
            (bool success, ) = p.call{value : msg.value}("");
            require(success, "Payment failed.");
            return "Voting closed.";
        }
    }
    function getBlockCount(address a) public view returns (uint){
        return blockCount[a];
    }
    function viewStatus(string calldata hashValue) public view returns (returnStatus memory){
        returnStatus memory r = returnStatus(m[hashValue].link, m[hashValue].positive, m[hashValue].total, 
                        m[hashValue].completed, m[hashValue].publisher, m[hashValue].publishTime, m[hashValue].genuine);
        return r;
        // string link;
        // uint256 positive;
        // uint256 total;
        // bool completed;
        // address payable publisher;
        // uint256 publishTime;
        // bool genuine;
    }

    function distributeRewards(string memory hashValue) private{
        uint pos;
        if(m[hashValue].genuine == true){
            pos = m[hashValue].positive;
        } 
        else{
            pos = m[hashValue].total - m[hashValue].positive;
        }
        uint rem = (m[hashValue].fees + m[hashValue].total*10000000000000000)%pos;
        uint prize = (m[hashValue].fees + m[hashValue].total*10000000000000000)/pos;
        address payable publisher = m[hashValue].publisher;
        if(rem != 0 && m[hashValue].genuine == true){
            (bool success, ) = publisher.call{value : rem}("");
            require(success, "Payment failed.");
        }
        for(uint i = 0; i<m[hashValue].total; i++){
            if(m[hashValue].votes[i].favor == m[hashValue].genuine){
                address payable voter = m[hashValue].votes[i].a;
                (bool success, ) = voter.call{value : prize}("");
                require(success, "Payment failed");
            }
        }
    }

    function isCompleted(string calldata hashValue) public view returns (bool){
        return m[hashValue].completed;
    }


}




