import codecs
import json
import sqlite3
from web3 import Web3
from tkinter import *
import mysql.connector
from eth_keys import keys
from eth_utils import decode_hex
import datetime, calendar

ganache_url = "http://127.0.0.1:7545"
web3 = Web3(Web3.HTTPProvider(ganache_url))
web3.eth.default_account = web3.eth.accounts[0]
address = web3.to_checksum_address("0x0EA1Ff7fcB7035Edb3A468238448B1d7116DF264")
abi = json.loads('[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"string","name":"hashValue","type":"string"},{"indexed":false,"internalType":"bool","name":"favor","type":"bool"},{"indexed":false,"internalType":"address","name":"voter","type":"address"}],"name":"CastVote","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"string","name":"hashValue","type":"string"},{"indexed":false,"internalType":"bool","name":"genuine","type":"bool"},{"indexed":false,"internalType":"uint256","name":"total","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"positive","type":"uint256"}],"name":"Completion","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"a","type":"address"},{"indexed":false,"internalType":"string","name":"err","type":"string"},{"indexed":false,"internalType":"uint256","name":"time","type":"uint256"}],"name":"ErrorMessage","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"string","name":"hashValue","type":"string"},{"indexed":false,"internalType":"address","name":"publisher","type":"address"},{"indexed":false,"internalType":"string","name":"link","type":"string"},{"indexed":false,"internalType":"uint256","name":"time","type":"uint256"}],"name":"Published","type":"event"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"blockCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"hashValue","type":"string"},{"internalType":"bool","name":"f","type":"bool"}],"name":"castVote","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"a","type":"address"}],"name":"getBlockCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"hashValue","type":"string"}],"name":"isCompleted","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"","type":"string"}],"name":"m","outputs":[{"internalType":"string","name":"link","type":"string"},{"internalType":"uint256","name":"positive","type":"uint256"},{"internalType":"uint256","name":"total","type":"uint256"},{"internalType":"bool","name":"completed","type":"bool"},{"internalType":"uint256","name":"fees","type":"uint256"},{"internalType":"address payable","name":"publisher","type":"address"},{"internalType":"uint256","name":"publishTime","type":"uint256"},{"internalType":"bool","name":"genuine","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"hashValue","type":"string"},{"internalType":"string","name":"link","type":"string"}],"name":"publish","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"string","name":"hashValue","type":"string"}],"name":"viewStatus","outputs":[{"components":[{"internalType":"string","name":"link","type":"string"},{"internalType":"uint256","name":"positive","type":"uint256"},{"internalType":"uint256","name":"total","type":"uint256"},{"internalType":"bool","name":"completed","type":"bool"},{"internalType":"address payable","name":"publisher","type":"address"},{"internalType":"uint256","name":"publishTime","type":"uint256"},{"internalType":"bool","name":"genuine","type":"bool"}],"internalType":"struct MalwareDetection.returnStatus","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"stateMutability":"payable","type":"receive"}]')

contract = web3.eth.contract(address=address, abi = abi)

class Member():
    def login(address, private_key):
        try:
            pkb = decode_hex(private_key)
        except:
            return 0
        pk = keys.PrivateKey(pkb)
        puk = pk.public_key
        if address==puk.to_checksum_address():
            # if contract.functions.getRating(address).call() == 0:
            #     return 2
            # else :
            #     current_address = address
            #     return 1
            return 1
        else : 
            return 0
    def verify(address, private_key):
        try:
            pkb = decode_hex(private_key)
        except:
            return 0
        pk = keys.PrivateKey(pkb)
        puk = pk.public_key
        if address==puk.to_checksum_address():
            # if contract.functions.getRating(address).call() == 0:
            #     return 2
            # else :
            #     current_address = address
            #     return 1
            return 1
        else : 
            return 0
        
    def publish(hashValue, link, address, private_key):
        b = contract.functions.getBlockCount(address).call()
        fees = b+1
        bal = web3.eth.get_balance(address)
        bal = web3.from_wei(bal, 'ether')
        if bal < fees:
            return "Insufficient balance."
            # web3.eth.default_account = web3.eth.accounts[1]
        tx = contract.functions.publish(hashValue, link).build_transaction({"from" : address, "value" :1000000000000000000*(fees), "nonce"  : web3.eth.get_transaction_count(address), "gas" : 6721975000,"gasPrice" : web3.  to_wei('2000000000',   'wei')})
        signed_tx = web3.eth.account.sign_transaction(tx, private_key)
        tx_hash = web3.eth.send_raw_transaction(signed_tx.rawTransaction)
        receipt = web3.eth.wait_for_transaction_receipt(tx_hash)
        # except ValueError as e:
        #     print(f"Error: {e}")
        # except Exception as e:
        #     print(f"Unknown error: {e}")
    #     except web3.exceptions.ContractLogicError as error:
    #   # Check if error.args is available (might not be in all versions of web3.py)
    #         if len(error.args) > 0:
    #             revert_reason = error.args[0].hex()  # Reason might be encoded in hex
    #             print(f"Revert Reason (hex): {revert_reason}")
    #     # You can try decoding the hex string if necessary (potentially platform-specific)
    #         else:
    #             print("Error accessing revert reason. Consider checking the transaction receipt logs for details.")

    def vote(hashValue, favor, address, private_key):
        tx = contract.functions.castVote(hashValue, favor).build_transaction({"from" : address, "value" : 10000000000000000,     "nonce" : web3.eth.get_transaction_count(address), "gas" : 6721975000, "gasPrice" : web3.to_wei('2000000000',  'wei')})
        signed_tx = web3.eth.account.sign_transaction(tx, private_key)
        tx_hash = web3.eth.send_raw_transaction(signed_tx.rawTransaction)
        receipt = web3.eth.wait_for_transaction_receipt(tx_hash)
    def voteGenuine(hashValue, address, private_key):
        Member.vote(hashValue, True, address, private_key)
    def voteFake(hashValue, address, private_key):
        Member.vote(hashValue, False, address, private_key)

    def blcokCount(address):
        return contract.functions.getBlockCount(address).call()

    def getInfo(hashValue):
        info = contract.functions.viewStatus(hashValue).call()
        return info

    def filt():
        # filter = web3.eth.filter({"fromBlock": 0, "address": address})
        filter = contract.events.Completion.create_filter(fromBlock=0)
        #print data of attributedict of all entries
        for entry in filter.get_all_entries():
            #convert hex to plaintext english
            print(entry.args)
        # print(filter.get_all_entries())
    def filterPublish():
        filter = contract.events.Published.create_filter(fromBlock=0)
        for entry in filter.get_all_entries():
            print(entry.args)
    
    def filterError(address, timestamp):
        filter = contract.events.ErrorMessage.create_filter(fromBlock=0)
        for entry in filter.get_all_entries():
            if entry.args.time >= timestamp :
                return entry.args.err
            # print(entry.args)
        
    def getLast1week():
        ans = []
        filter = contract.events.Published.create_filter(fromBlock=0)
        for entry in filter.get_all_entries():
            if entry.args.time >= calendar.timegm(datetime.datetime.now(datetime.UTC).utctimetuple()) - 604800:
                ans.append(entry.args.hashValue)
        return ans

    def isCompleted(hashValue):
        ret = contract.functions.isCompleted(hashValue).call()
        return ret
    
# publish("abcdwsf", "123.com", "0xf1529bADF57F52736D1Df412C37148972fd15f3E", "0x1a06f1f1e35d923941623628a59d6b05b337276d11e0c1359d705e9217646af0")
# vote("abcd", False, "0xB2B998BBb97b2459Ee1bBdfCBB1227F0AA403Fd3", "0xe466a215ffd6e15463412b8f2715feb17e2167cf91e6ace5c3c583096223095c")
# print(contract.events.Published().get_logs(argument_filters={"hashValue": "abcd"}, from_block=0, to_block="latest"))
# Member.filt()
# date = datetime.datetime.utcnow()
# utc_time = calendar.timegm(date.utctimetuple())
# print(utc_time)
# import calendar
# import datetime
 
# date = datetime.datetime.now(datetime.UTC)
# utc_time = calendar.timegm(date.utctimetuple())
# Member.publish("abcd", "123.com", "0x4834683889FfE88Bdc046F817262986b855d1f53", "0x9574cf841d1c4e627e6dbae4b58e1a1b7ceb42e23b45c94e296ee64ab4f1ceb6")
# Member.filterError("0x4834683889FfE88Bdc046F817262986b855d1f53", utc_time)
# print(Member.getInfo("abcd"))
                